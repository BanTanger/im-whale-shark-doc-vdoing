---
title: TCP服务对接Zk
date: 2023-03-26 10:09:30
permalink: /pages/9b104d/
categories:
  - 项目
  - 高性能IM即时通讯系统
tags:
  - 
author: 
  name: BanTanger | 半糖
  link: https://github.com/bantanger
---
## 背景

在 IM 系统架构规划之初，就确立了是对接多个服务的即时通讯系统。单机 server 无法抗下日益剧增的并发，因此需要分布式 server 来实现流量分摊。而一旦使用到分布式，就无可避免的需要通过注册中心来实现服务的注册与发现



## 概念

### 为什么一定要使用注册中心，直接将服务器 IP 地址配置在 TCP 网关里不行吗?

直接将服务器 IP 地址配置在 TCP 网关，即每个服务都配置部署它的服务器 IP，如部署 A 服务的 IP 地址为 `192.168.1.1` 和 `192.168.1.2` 。但这样带来的弊端就是，当服务器新增或缩减时，需要在每一台机器上手动的进行配置



### 可以通过反向代理的手段实现转发吗

传统的 HTTP 服务器可以通过反向代理把请求转发到可用的服务，但这个方案在即时通讯不能采用。

HTTP 服务器和即时通讯服务区别：

1.协议：HTTP 服务器使用的是 HTTP 协议，而即时通讯服务使用的协议通常是专用的即时通讯协议，比如 XMPP（Jabber）、Websocket、MQTT 等。

2.请求和响应特点：HTTP 服务是基于请求和响应的，客户端发送请求，服务器响应请求，完成一个 HTTP 请求后会断开连接，即时通讯服务则需要保持连接不断开，能够实时地推送消息或者接收消息。

3.适用场景：HTTP 服务器主要用于传送静态页面、文件等资源，适用于客户端与服务器之间不需要频繁通讯的场景；即时通讯服务则适用于需要实时通讯的场景，比如聊天室、在线客服、实时游戏等。

4.数据处理方式：HTTP 服务器通常采用短连接方式进行数据传输，即每个请求响应都是分离的，而即时通讯服务通常采用长连接方式，数据传输是在一个持久化的连接上进行的，可以支持类似推送等高级数据交互。



### "无状态"和"有状态"

"无状态"和"有状态"是描述网络服务的两个概念。HTTP 服务器是无状态服务，这意味着它并不记录客户端与服务器之间的任何状态信息，每个请求都是独立的，HTTP 服务器对于一次请求响应之后会立即关闭连接，下次请求需要重新建立连接再次发送请求。

而即时通讯服务是有状态服务，这意味着它会在服务器端记录客户端和服务器之间的状态信息，比如连接状态、收发的消息等等。即时通讯服务需要记录各个客户端连接的状态，以保证通讯的顺利进行，而这些状态信息可能会持续存在一段时间，不会在每个请求响应之后立即被删除。

理解无状态服务和有状态服务的区别，可以思考这样一个例子：假设有一个网站需要您登录之后才能进行某些操作。在无状态服务中，每次您请求该网站中的某个页面或功能时，都需要重新进行身份认证才能获得权限；而在有状态服务中，您只需要登录一次，之后即使访问不同的页面或功能，服务器也会知道您是已经登录过的，无需重新进行身份认证。

在即时通讯系统中，由于客户端需要长时间保持连接，服务器需要存储这些维持连接的状态信息，因此就是有状态服务。



### 在 HTTP 服务器中用 Redis 来存储用户的 Session 信息，不也能实现 SSO 吗

Session 是有状态的，因此可以实现当用户在应用程序的一个服务器上登录，会话信息会被存储在 Redis 中，当用户访问应用的另一个服务器时，可以从 Redis 中获取用户已经登录的会话信息，这样即可实现跨服务器的单点登录。

不过需要注意的是，虽然可以通过 Redis 存储 session 信息，但仅仅存储 session 信息并不能完全解决单点登录的问题，仍然需要进行一些相关的安全性和身份验证的设计。比如可以将会话信息和用户的身份信息绑定，使用签名机制保证会话信息的安全性，防止会话劫持等问题出现。

一般来说，在分布式环境下实现单点登录需要考虑以下几个方面：

1. 统一认证中心：所有的应用共用一个认证中心，不同的应用可以通过 SSO（Single Sign On）协议来交互，实现单点登录。
2. 统一登录地址：所有的应用都应该重定向到一个统一的登录地址，用户只需要登录一次，所有应用就都可以共享单点登录信息。
3. 统一注销：用户在某个应用注销后，其他应用也应该同时注销，避免因为用户在一个应用注销后，在其他应用里还可以继续访问数据的问题。
4. 统一存储：所有应用共享同一个会话信息及登录凭证存储，比如可以使用 Redis 等内存缓存，数据存储的可靠性和访问速度需要保证。

因此，通过 Redis 存储 Session 信息只是单点登录的一个方面，当应用程序分布在多台服务器上时，还需要考虑更全面的分布式应用架构和安全机制的设计。

在现如今的架构中，通常都是通过请求携带 token 的方式实现登录逻辑



## CAP 理论



## 市场调研

主流注册中心有 

+ Eureka：老牌注册中心，2.x 版本已停止维护
+ Consul：多语言注册中心，但对 Java 项目的兼容性不好
+ Kubernetes(k8s)：方便扩容集群，但对于 IM 服务而言不太合适
+ Nacos：开源社区活跃，问题容易得到解决。具备 CP 和 AP 两种策略，可根据具体业务进行切换，但缺点在于体积庞大，对于服务器的压力较重。
+ Zookeeper：只有 CP 策略，当服务的注册越来越多时会导致响应时间较长，但可通过消息总线的方式提升容错。且 Zookeeper 具备强大的监听机制，可快速的进行服务下线上线的感知

综合考虑之下，选择使用 Zk 作为 IM 系统的注册中心。

理由有二：

+ IM 系统是有状态服务，需要时刻感知服务节点是否可用，若不可用，就会导致用户无法访问，这种问题出现在 IM 上是无容忍的
+ 即时真的分配了一个不可用的节点（心跳正常，但无法正常处理数据），Zk 也可通过熔断降级的方式返回固定返回值，例如说提示用户 ”活动火爆，稍后再试“，”当前活动正在维护“

所以在 TCP 服务中，是否能够及时感知服务节点状态是一个相当重要的技术选型点



## Zookeeper 重要原理

Zk 是一个分布式协调服务框架，其主要用于协调和管理分布式系统中的数据和进程，以实现高可用性和一致性。他的主要原理如下：

1. 原子广播：Zk 将所有操作都转换为一个有序的、全局的事件序列（Zxid），这些事件最终会广播给所有节点，确保所有节点都按照相同的顺序处理操作。这种方法由于其强一致性，使得 Zk 适用于多数种协调问题。
2. 数据节点：在 Zk 中，数据节点类似于文件系统中的节点。每个节点都可以存储一个值，这个值可以是任何数据类型（非空、无限制的byte数组），并能被监视、订阅或监听。
3. **临时节点**：服务端和客户端建立连接时，数据会存储在临时节点一直存在，客户端断开连接后自动被（延迟）删除。这是因为通常情况下临时节点用于表示节点状态或临时任务，而当客户端关闭或异常断开连接时，这些状态或任务已经失效，因此需要被清除。
4. 有序节点：有序节点是一种通常用于队列等场景的节点形式，每个节点都有一个自动分配的编号，以保证操作的有序性。
5. **监听（观察者）机制**：Zk 支持监控一个特定的节点，当该节点上线或下线时，客户端可以及时得到通知。例如 A、B 两个节点相互监听，当 A 节点下线时，Zk 感知，并将消息发送给 B 节点；这种机制在分布式环境下很有用，因为可以避免客户端轮询节点状态。



### Zk 特性

ZooKeeper（简称 zk）是一个开源的分布式协调服务框架，它具有以下特性：

1. 分布式协调：ZooKeeper 提供了一些常用的分布式协调服务，如：分布式锁、分布式队列、分布式选举等，方便开发人员协调分布式应用系统。
2. 高可用性：ZooKeeper 采用主备模式，可以保证在任一时刻都有一个主节点，其他节点为备节点，主节点下线后自动选举备节点中的一个作为新的主节点，并且可以自动同步数据，保证整个系统的高可用性。
3. 数据的一致性：ZooKeeper 基于 Paxos 算法和 ZAB（ZooKeeper Atomic Broadcast）协议，保证多个节点之间的数据一致性，避免因为多节点数据不一致导致系统出现问题。
4. 可靠性与可恢复性：ZooKeeper 的数据存储采用内存映射和事务存储机制，并支持备份和恢复数据等服务，可以保证数据的可靠性和系统的可恢复性。
5. 高扩展性：ZooKeeper 的节点采用树形结构进行组织，并且支持多个节点集群构成的分布式环境，可以根据需求方便地进行扩展。
6. 灵活的权限控制：ZooKeeper 对节点的访问可以设置不同的权限，保证数据的安全性。



### 基于消息总线优化 Zk 的 CP 策略

Zookeeper作为分布式协调服务，采用了CP（一致性和可用性）策略，保证了数据强一致性和高可用性。但在大规模应用场景下，因为Zookeeper的读写分离不够完善以及数据量较大等缺点，可能导致性能不佳和延迟较高等问题。

为了优化Zookeeper的CP策略，可以采用基于消息总线的架构设计，具体包括以下几个方面：

1. Kafka作为消息总线

Kafka是一款高吞吐量、低延迟的分布式消息队列，它支持多分区、多副本、分布式、持久化等特性。使用Kafka作为消息总线可以实现解耦，并避免直接访问Zookeeper造成的压力。

2. 基于Kafka实现Zookeeper数据同步

通过在Zookeeper中增加Kafka监听器，可以将Zookeeper中的数据变更实时同步到Kafka消息队列中，保证数据的实时性和准确性。同时，在客户端需要读取数据时，也直接从Kafka消息队列中获取，减轻了Zookeeper的访问压力。

3. 客户端缓存数据

在客户端缓存那些热点数据，从Kafka消息队列中获取数据，可以有效减轻Zookeeper的负载。为了保证数据的实时性，可以采用定时刷新缓存或者监听Kafka消息更新的方式来更新缓存。



### Zk 部署方式

Zookeeper 有三种部署模式：

1. 单机部署：一台集群上运行；
2. 集群部署：多台集群运行；
3. 伪集群部署：一台集群启动多个 Zookeeper 实例运行。（**需要调研**）



### Zk 集群

对于动态扩容 zk 做的不是太好，他有两种实现方式

一是通过全部重启：关闭所有的 zk 服务，修改配置之后重新启动，不影响之前客户端的会话，但会造成一段时间的服务不可用，因此一般是定期在凌晨进行维护

二是通过逐渐重启：在过半存活即可用的分布式理论下，我们可以逐个的对机器进行重启，。从而不影响整个集群对外提供服务



## 对接流程

父工程引入依赖

```xml
<!-- zookeeper -->
<dependency>
    <groupId>com.github.sgroschupf</groupId>
    <artifactId>zkclient</artifactId>
    <version>0.1</version>
</dependency>
```

config 配置

```yml
zkConfig:
  zkAddr: 127.0.0.1:2181
  zkConnectTimeOut: 5000
```



### 根节点名称定义

```java
public static class ZkConstants {

    public static final String ImCoreZkRoot = "/im-coreRoot";

    public static final String ImCoreZkRootTcp = "/tcp";

    public static final String ImCoreZkRootWeb = "/web";
}
```



能正常跑通并注册

![image-20230326131234972](https://cdn.statically.io/gh/BanTanger/image-hosting@master/20.MQ%E5%BC%82%E6%AD%A5%E8%A7%A3%E8%80%A6-assets/202303261312257.png)