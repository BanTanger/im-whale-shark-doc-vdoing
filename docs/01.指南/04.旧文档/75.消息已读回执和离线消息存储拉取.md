---
title: 消息已读回执和离线消息存储拉取
date: 2023-04-08 10:19:05
permalink: /pages/968bac/
categories:
  - 项目
  - 高性能IM即时通讯系统
tags:
  - 
author: 
  name: BanTanger | 半糖
  link: https://github.com/bantanger
---
## 消息已读

群聊已读回执

用一张表来记录每个用户读取消息的记录，每次用户读取最新消息时，都会将 last message 的 messageSequence 上报给服务端

修改表结构：群成员表，增添消息偏序字段来记录消息已读情况；（适合写扩散）

或者是将消息偏序与会话绑定（适合读扩散）因为每个用户都与群组建立一个会话消息队列

对于读扩散而言，可以用一张表记录用户与用户之间的消息已读偏序

+ 对于在线用户，直接上报消息偏序给服务端，服务端传递给对方，标识该消息在线用户已读
+ 对于离线用户，根据用户最后一次登陆所记录的消息已读偏序与当前消息偏序做差值，可以做拉取操作

对于写扩散而言，例如钉钉、飞书这样的专门为了办公商业化而生的软件，由于一条群消息会写入所有成员的消息队列中，可以往数据库表新增一个用户已读消息字段的偏序来标识用户当前读到那一条消息。更加精准

总结群聊消息的读写扩散进行已读回执：

读扩散需要再维护一张表来记录用户与用户、用户与群聊消息（其实是用户与发布者）的消息已读记录

而写扩散因为天生就需要让每一个群成员记录消息信息，可以直接添加一个已读偏序字段。实现更加精细的消息已读功能



### 微信架构

不知有没有遇到这样的场景，手机微信开启了消息未读提醒，每当有新消息来时可以及时收到。这看似很人性化。

但当我们使用 pc 端微信和产品 battle 时，我们会发现，手机端的微信一直在响个不停... 

其实微信是有实现消息已读功能。消息已读也可以通知给同步端。只需要在客户端设置当电脑发送消息时，取消手机的消息提醒即可

Whale-Shark 采用这种将消息已读通知给同步端的策略提升用户体验

本 IM 架构所需的已读回执状态码

| 消息含义                             | 状态码                  |
| ------------------------------------ | ----------------------- |
| 发送消息已读(1106)                   | MSG_READ(0x452)         |
| 消息已读 TCP 通知发送给同步端(1053)  | MSG_READ_NOTIFY(0x41D)  |
| 消息已读回执发送给原消息发送方(1054) | MSG_READ_RECEIPT(0x41E) |

功能需求：

1. 发送方发出消息给服务端
2. 接收方接收消息并发送已读确认给服务端
3. 更新接收方客户端状态
4. 服务端将已读确认分发给发送方所有端进行同步
5. 更新发送方客户端状态



![image-20230408132456385](https://cdn.statically.io/gh/BanTanger/image-hosting@master/75.%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-assets/202304081325843.png)

+ 收到已读确认和已读回执

![image-20230408155235160](https://cdn.statically.io/gh/BanTanger/image-hosting@master/75.%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-assets/202304081552377.png)

群组已读确认



## 离线消息存储与拉取

### 离线消息

离线消息是在目标用户当前不在线时，发送者向服务器发送的消息。服务器将离线消息存储下来，待用户上线后将离线消息推送给用户。

+ 不进入会话窗口，即只在会话列表就可拉取消息
+ 存储消息有限，基于消息条数维度进行存储（依据产品设计而定，WhaleShark 设置成 1024 条）



### 历史消息

历史消息则是指已经发送并接收过的消息，这些消息保存在用户聊天记录中，用户可以在任何时间查看这些消息。

+ 通过消息漫游拉取，进入会话窗口才可拉取消息
+ 存储消息也有限，但基本是以时间维度进行存储（六个月、一年、两年...)



### 存储介质

由于离线消息的使用场景就是让用户上线时获取到所有会话列表中最新的消息而不用点击进会话里拉取。所以离线消息的存储是十分有限的。并且是一个非常高频的增添和删除过程。下面考虑的存储介质

- [ ] MySQL

- [x] Redis

MySQL 十分不合适，因为数据是需要经常更替的，频繁的读写过程会增添 MySQL 的压力。并且设计上 MySQL 是需要**硬删除**过期数据的（软删除属于历史消息），而删除时会添加行锁，对于要边读边删的情况就不太友好了

Redis 比较合适，他是基于内存的数据库，删除和写入都十分高效快速



### 怎么存储

redis 的 list、set、zset 都可以存储列表消息

list 不建议使用，**因为 list 无法分页？（有误，之后调研）**，每次只能从离线消息队列同步拉取消息，对于用户体验来说是不友好的，我们希望每次拉取消息都是之前用户没看到的

set 也不建议使用，因为 set 无法做到排序，当数据量小时可以拉取出来在内存中排序，但当数据量大的时候就很难实现了

zset ，我们可以利用 zset 的分数 score 字段，来进行消息的存储和拉取，使用绝对递增 messageKey 作为 score，不仅可以支持排序，内部提供的 API 也可以保证用户不会拉取到上一次登录拉取过的内容

```java
Key: appId + ":OfflineMessage:" + userId
```

redis 存储结构：

```java
ZSet(key, JSON(offlineMessage), messageKey);
```

![image-20230408213826198](https://cdn.statically.io/gh/BanTanger/image-hosting@master/75.%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-assets/202304082138949.png)

群聊离线消息功能测试正常

![image-20230408213856276](https://cdn.statically.io/gh/BanTanger/image-hosting@master/75.%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-assets/202304082138753.png)

单聊离线消息功能正常

![image-20230408213943412](https://cdn.statically.io/gh/BanTanger/image-hosting@master/75.%E6%B6%88%E6%81%AF%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-assets/202304082139351.png)